{"1763479098999":{"actionType":"saveAll","createdAt":"1763479098999","actionID":"1763479098999","userID":"#TEMP","path":"system.capsules.4a541072-7bf3-4396-87fd-11e9879a9e04.capsUseCodeInfo.capsUseInputs.sss_freeValue-0.capsIptTxtValue","oldValue":"// ---------- import Packs\nimport JSON5 from \"json5\";\nimport React from \"react\";\nimport { TextInput } from \"react-native\";\n\n// ---------- import Local Tools\nimport { useData } from \"../../..\";\nimport { getStlValues, getVarValue, pathSel, setData } from \"../project\";\n\ntype TFunc = (val: string, args?: any) => any | Promise<any>;\n\ntype Tprops = {\n  pass: {\n    propsArray?: any[];\n    stylesArray?: any[];\n    funcsArray?: TFunc[]; // opcional\n    path: (string | number)[];\n    args?: any;\n  };\n};\n\n// IptTxtEdit - Entrada de Texto com prop value\nexport const IptTxtEdit = (props: Tprops) => {\n  const {\n    propsArray = [],\n    stylesArray = [],\n    funcsArray = [],\n    path,\n    args,\n  } = props.pass;\n\n  const joinedPath = path.join();\n\n  // Estado local\n  const [sttText, setText] = React.useState(\"\");\n\n  // Leitura do store (sempre segura; só vamos usar quando for o caso)\n  const editData = useData((ct) => pathSel(ct, joinedPath));\n\n  // Tem handlers externos?\n  const hasExternal = Array.isArray(funcsArray) && funcsArray.length > 0;\n\n  // Hidrata do store apenas quando há fluxo externo\n  React.useEffect(() => {\n    if (!hasExternal) return;\n    if (editData !== undefined && editData !== sttText) {\n      setText(String(editData));\n    }\n  }, [editData, hasExternal, sttText]);\n\n  // onChange: decide o “modo”\n  const getTxt = (val: string) => {\n    if (!hasExternal) {\n      // modo interno: só estado local\n      setText(val);\n      return;\n    }\n\n    // modo externo: mantém input responsivo e sincroniza store\n    let masked: string | undefined;\n\n    for (const fn of funcsArray) {\n      try {\n        const result = fn(val, args);\n\n        // Se for Promise, trata como efeito colateral assíncrono\n        if (result && typeof (result as any).then === \"function\") {\n          (result as Promise<any>).catch((err) => {\n            console.error(\"Erro em função externa async:\", err);\n          });\n          continue;\n        }\n\n        // Se retornar string, usamos como máscara\n        if (typeof result === \"string\" && result.length > 0) {\n          masked = result;\n        }\n      } catch (err) {\n        console.error(\"Erro em função externa:\", err);\n      }\n    }\n\n    const finalValue = masked ?? val;\n\n    setText(finalValue);\n    setData({ path: joinedPath, value: finalValue });\n  };\n\n  // ---------- Styles\n  const stlsUser = getStlValues(stylesArray);\n\n  // ---------- Extra props do usuário\n  const userElProps: Record<string, any> = {};\n  for (const strObj of propsArray) {\n    if (!strObj || typeof strObj !== \"string\") continue;\n    const parsed = JSON5.parse(strObj);\n    for (const key in parsed) {\n      const value = parsed[key];\n      const [hasVar, varValue] = getVarValue(value);\n      userElProps[key] = hasVar ? varValue : value;\n    }\n  }\n\n  const allProps = {\n    style: stlsUser,\n    value: sttText,\n    onChangeText: getTxt,\n    placeholder: \"Escreva...\",\n    placeholderTextColor: \"#ccc\",\n    ...userElProps,\n  };\n\n  return <TextInput {...allProps} />;\n};","newValue":"// ---------- import Packs\nimport JSON5 from 'json5';\nimport React from 'react';\nimport { TextInput } from 'react-native';\n\n// ---------- import Local Tools\nimport { useData } from '../../..';\nimport { getStlValues, getVarValue, pathSel, setData } from '../project';\n\ntype TFunc = (val: string, args?: any) => any | Promise<any>;\n\ntype Tprops = {\n  pass: {\n    propsArray?: any[];\n    stylesArray?: any[];\n    funcsArray?: TFunc[]; // opcional\n    path: (string | number)[];\n    args?: any;\n  };\n};\n\n// IptTxtEdit - Entrada de Texto com prop value\nexport const IptTxtEdit = (props: Tprops) => {\n  const {\n    propsArray = [],\n    stylesArray = [],\n    funcsArray = [],\n    path,\n    args,\n  } = props.pass;\n\n  const joinedPath = path.join();\n\n  // Estado local\n  const [sttText, setText] = React.useState('');\n\n  // Leitura do store (sempre segura; só vamos usar quando for o caso)\n  const editData = useData(ct => pathSel(ct, joinedPath));\n\n  // Tem handlers externos?\n  const hasExternal = Array.isArray(funcsArray) && funcsArray.length > 0;\n\n  // Hidrata do store apenas quando há fluxo externo\n  React.useEffect(() => {\n    if (!hasExternal) return;\n    if (editData !== undefined && editData !== sttText) {\n      setText(String(editData));\n    }\n  }, [editData, hasExternal, sttText]);\n\n  // onChange: decide o “modo”\n  const getTxt = async (val: string) => {\n    if (!hasExternal) {\n      // modo interno: só estado local\n      setText(val);\n      return;\n    }\n\n    // modo externo: mantém input responsivo e sincroniza store\n    setText(val); // feedback imediato\n    setData({ path: joinedPath, value: val });\n    for (const fn of funcsArray) {\n      await fn(val, args);\n    }\n  };\n\n  // ---------- Styles\n  const stlsUser = getStlValues(stylesArray);\n\n  // ---------- Extra props do usuário\n  const userElProps: Record<string, any> = {};\n  for (const strObj of propsArray) {\n    if (!strObj || typeof strObj !== 'string') continue;\n    const parsed = JSON5.parse(strObj);\n    for (const key in parsed) {\n      const value = parsed[key];\n      const [hasVar, varValue] = getVarValue(value);\n      userElProps[key] = hasVar ? varValue : value;\n    }\n  }\n\n  const allProps = {\n    style: stlsUser,\n    value: sttText,\n    onChangeText: getTxt,\n    placeholder: 'Escreva...',\n    placeholderTextColor: '#ccc',\n    ...userElProps,\n  };\n\n  return <TextInput {...allProps} />;\n};"}}