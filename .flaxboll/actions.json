{"1763483195090":{"actionType":"saveAll","createdAt":"1763483195090","actionID":"1763483195090","userID":"#TEMP","path":"system.capsules.4a541072-7bf3-4396-87fd-11e9879a9e04.capsUseCodeInfo.capsUseInputs.sss_freeValue-0.capsIptTxtValue","oldValue":"// ---------- import Packs\nimport JSON5 from 'json5';\nimport React from 'react';\nimport { TextInput } from 'react-native';\n\n// ---------- import Local Tools\nimport { useData } from '../../..';\nimport { getStlValues, getVarValue, pathSel, setData } from '../project';\n\ntype TFunc = (val: string, args?: any) => any | Promise<any>;\n\ntype Tprops = {\n  pass: {\n    propsArray?: any[];\n    stylesArray?: any[];\n    funcsArray?: TFunc[]; // opcional\n    path: (string | number)[];\n    args?: any;\n  };\n};\n\n// IptTxtEdit - Entrada de Texto com prop value\nexport const IptTxtEdit = (props: Tprops) => {\n  const {\n    propsArray = [],\n    stylesArray = [],\n    funcsArray = [],\n    path,\n    args,\n  } = props.pass;\n\n  const joinedPath = path.join();\n\n  // Estado local\n  const [sttText, setText] = React.useState('');\n\n  // Leitura do store (sempre segura; só vamos usar quando for o caso)\n  const editData = useData(ct => pathSel(ct, joinedPath));\n\n  // Tem handlers externos?\n  const hasExternal = Array.isArray(funcsArray) && funcsArray.length > 0;\n\n  // Hidrata do store apenas quando há fluxo externo\n  React.useEffect(() => {\n    if (!hasExternal) return;\n    if (editData !== undefined && editData !== sttText) {\n      setText(String(editData));\n    }\n  }, [editData, hasExternal, sttText]);\n\n  // onChange: decide o “modo”\n  const getTxt = async (val: string) => {\n    if (!hasExternal) {\n      // modo interno: só estado local\n      setText(val);\n      return;\n    }\n\n    // modo externo: mantém input responsivo e sincroniza store\n    setText(val); // feedback imediato\n    setData({ path: joinedPath, value: val });\n    for (const fn of funcsArray) {\n      await fn(val, args);\n    }\n  };\n\n  // ---------- Styles\n  const stlsUser = getStlValues(stylesArray);\n\n  // ---------- Extra props do usuário\n  const userElProps: Record<string, any> = {};\n  for (const strObj of propsArray) {\n    if (!strObj || typeof strObj !== 'string') continue;\n    const parsed = JSON5.parse(strObj);\n    for (const key in parsed) {\n      const value = parsed[key];\n      const [hasVar, varValue] = getVarValue(value);\n      userElProps[key] = hasVar ? varValue : value;\n    }\n  }\n\n  const allProps = {\n    style: stlsUser,\n    value: sttText,\n    onChangeText: getTxt,\n    placeholder: 'Escreva...',\n    placeholderTextColor: '#ccc',\n    ...userElProps,\n  };\n\n  return <TextInput {...allProps} />;\n};","newValue":"// ---------- import Packs\nimport JSON5 from 'json5';\nimport React from 'react';\nimport { TextInput } from 'react-native';\n\n// ---------- import Local Tools\nimport { useData } from '../../..';\nimport { getStlValues, getVarValue, pathSel, setData } from '../project';\n\ntype TFunc = (val: string, args?: any) => any | Promise<any>;\n\ntype Tprops = {\n  pass: {\n    propsArray?: any[];\n    stylesArray?: any[];\n    funcsArray?: TFunc[]; // opcional\n    path: (string | number)[];\n    args?: any;\n  };\n};\n\n// IptTxtEdit - Entrada de Texto com prop value\nexport const IptTxtEdit = (props: Tprops) => {\n  const {\n    propsArray = [],\n    stylesArray = [],\n    funcsArray = [],\n    path,\n    args,\n  } = props.pass;\n\n  const joinedPath = path.join();\n\n  // Estado local\n  const [sttText, setText] = React.useState('');\n\n  // Leitura do store (sempre segura; só vamos usar quando for o caso)\n  const editData = useData(ct => pathSel(ct, joinedPath));\n\n  // Tem handlers externos?\n  const hasExternal = Array.isArray(funcsArray) && funcsArray.length > 0;\n\n  // Hidrata do store apenas quando há fluxo externo\n  React.useEffect(() => {\n    if (!hasExternal) return;\n    if (editData !== undefined && editData !== sttText) {\n      setText(String(editData));\n    }\n  }, [editData, hasExternal, sttText]);\n\n  // onChange: decide o “modo”\n  const getTxt = async (val: string) => {\n    if (!hasExternal) {\n      // modo interno: só estado local\n      setText(val);\n      return;\n    }\n\n    // modo externo: mantém input responsivo e sincroniza store\n    setText(val); // feedback imediato\n    for (const fn of funcsArray) {\n      await fn(val, args);\n    }\n  };\n\n  // ---------- Styles\n  const stlsUser = getStlValues(stylesArray);\n\n  // ---------- Extra props do usuário\n  const userElProps: Record<string, any> = {};\n  for (const strObj of propsArray) {\n    if (!strObj || typeof strObj !== 'string') continue;\n    const parsed = JSON5.parse(strObj);\n    for (const key in parsed) {\n      const value = parsed[key];\n      const [hasVar, varValue] = getVarValue(value);\n      userElProps[key] = hasVar ? varValue : value;\n    }\n  }\n\n  const allProps = {\n    style: stlsUser,\n    value: sttText,\n    onChangeText: getTxt,\n    placeholder: 'Escreva...',\n    placeholderTextColor: '#ccc',\n    ...userElProps,\n  };\n\n  return <TextInput {...allProps} />;\n};"},"1763483195091":{"actionType":"saveAll","createdAt":"1763483195091","actionID":"1763483195091","userID":"#TEMP","path":"system.capsules.8abe2226-b89c-4398-b08f-50f59f28b837.capsUseCodeInfo.capsUseInputs.sss_custom_caps-0.capsIptTxtValue","oldValue":"(txt) => {\n  try {\n    if (typeof txt !== \"string\") txt = String(txt ?? \"\");\n\n    // Mantém apenas números\n    let clean = txt.replace(/\\D/g, \"\");\n\n    // Limita a 8 dígitos (ddmmyyyy)\n    if (clean.length > 8) clean = clean.slice(0, 8);\n    console.log({ clean });\n    \n  } catch (e) {\n    console.error(\"Erro na máscara de data:\", e);\n  }\n}","newValue":"(txt) => {\n  try {\n    if (typeof txt !== \"string\") txt = String(txt ?? \"\");\n\n    // Mantém apenas números\n    let xxx = txt.replace(\"/\", \"\");\n    console.log({ xxx });\n    \n    let clean = txt.replace(/\\D/g, \"\");\n\n    // Limita a 8 dígitos (ddmmyyyy)\n    if (clean.length > 8) clean = clean.slice(0, 8);\n    console.log({ clean });\n    \n  } catch (e) {\n    console.error(\"Erro na máscara de data:\", e);\n  }\n}"}}