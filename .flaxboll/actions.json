{"1762281653984":{"actionType":"saveAll","createdAt":"1762281653984","actionID":"1762281653984","userID":"#TEMP","path":"system.capsules.0e1ba4b0-147d-4499-abf4-4ed9d8debb14.capsUseCodeInfo.capsUseInputs.sss_freeValue-0.capsIptTxtValue","oldValue":"import { getDownloadURL, getStorage, ref, uploadBytes } from \"firebase/storage\";\nimport { getCtData, testVarType } from \"../../project\";\n\ntype Tprops = {\n  args: any;\n  pass: { arrFiles: any[]; arrFuncs?: Array<(a: any, urls: string[], idx?: number) => any> };\n};\n\n// --- helpers\nconst safeName = (name: string) =>\n  (name || \"file.bin\").replace(/[^\\w.\\-]+/g, \"_\").slice(-150);\n\nconst extFromMime = (mime?: string) =>\n  mime && mime.indexOf(\"/\") !== -1 ? \".\" + mime.split(\"/\")[1] : \"\";\n\nasync function toBlobAndName(input: any, idx: number): Promise<{ blob: Blob; name: string }> {\n  // WEB: File/Blob real\n  if (input instanceof Blob) {\n    const name =\n      (input as any).name ||\n      \"upload_\" + Date.now() + \"_\" + idx + (extFromMime((input as any).type) || \".bin\");\n    return { blob: input, name: safeName(name) };\n  }\n\n  // NATIVO: { uri, fileName?, mimeType? }\n  if (input && typeof input === \"object\" && typeof input.uri === \"string\") {\n    const res = await fetch(input.uri);\n    const blob = await res.blob();\n    const name =\n      input.fileName ||\n      \"upload_\" + Date.now() + \"_\" + idx + (extFromMime(input.mimeType || blob.type) || \".bin\");\n    return { blob, name: safeName(name) };\n  }\n\n  // STRING (blob:/file:/content:/http:)\n  if (typeof input === \"string\") {\n    const res = await fetch(input);\n    const blob = await res.blob();\n    const name = \"upload_\" + Date.now() + \"_\" + idx + (extFromMime(blob.type) || \".bin\");\n    return { blob, name: safeName(name) };\n  }\n\n  throw new Error(\"Formato de arquivo não suportado\");\n}\n\nexport const uploadFileTool = async (props: Tprops) => {\n  console.log(\"UPLOAD DE ARQUIVOS\");\n  const { args, pass } = props;\n  const { arrFiles, arrFuncs } = pass || {};\n  console.log({ arrFiles, arrFuncs });\n\n  if (!arrFiles || !arrFiles.length) return [];\n\n  const resolved = arrFiles.map((v) => testVarType(v, args));\n  const inputs: any[] = Array.isArray(resolved[0]) ? resolved[0] : resolved;\n  console.log(\"inputs normalizados:\", inputs);\n\n  const fbInit = getCtData(\"all.temp.fireInit\");\n  const storage = getStorage(fbInit);\n\n  // --- faz upload de cada imagem e guarda as URLs\n  const results = await Promise.all(\n    inputs.map(async (currData: any, idx: number) => {\n      try {\n        const data = await toBlobAndName(currData, idx);\n        const blob = data.blob;\n        const name = data.name;\n        const path = \"images/\" + Date.now() + \"_\" + idx + \"_\" + name;\n        const fileRef = ref(storage, path);\n\n        await uploadBytes(fileRef, blob);\n        const url = await getDownloadURL(fileRef);\n\n        console.log(\"upload ok:\", { idx, path, url });\n        return { ok: true, idx: idx, url: url, path: path };\n      } catch (err) {\n        console.error(\"falha no upload:\", idx, err);\n        return { ok: false, idx: idx, error: String(err) };\n      }\n    })\n  );\n\n  // --- coleta somente as URLs válidas\n  const urls = results.filter(r => r.ok).map(r => r.url);\n  console.log(\"URLs finais:\", urls);\n\n  // --- chama funções externas APÓS todos os uploads\n  if (arrFuncs && arrFuncs.length) {\n    for (const fn of arrFuncs) {\n      await fn(args, urls);\n    }\n  }\n\n  console.log(\"Resultados:\", results);\n  return results;\n};","newValue":"import { getDownloadURL, getStorage, ref, uploadBytes } from \"firebase/storage\";\nimport { getCtData, testVarType } from \"../../project\";\n\ntype Tprops = {\n  args: any;\n  pass: {\n    arrFiles: any[];\n    arrFuncs?: Array<(a: any, urls: string[], idx?: number) => any>;\n  };\n};\n\n// --- helpers\nconst safeName = (name: string) =>\n  (name || \"file.bin\").replace(/[^\\w.\\-]+/g, \"_\").slice(-150);\n\nconst extFromMime = (mime?: string) =>\n  mime && mime.indexOf(\"/\") !== -1 ? \".\" + mime.split(\"/\")[1] : \"\";\n\nasync function toBlobAndName(\n  input: any,\n  idx: number\n): Promise<{ blob: Blob; name: string }> {\n  // WEB: File/Blob real\n  if (input instanceof Blob) {\n    const name =\n      (input as any).name ||\n      \"upload_\" +\n        Date.now() +\n        \"_\" +\n        idx +\n        (extFromMime((input as any).type) || \".bin\");\n    return { blob: input, name: safeName(name) };\n  }\n\n  // NATIVO: { uri, fileName?, mimeType? }\n  if (input && typeof input === \"object\" && typeof input.uri === \"string\") {\n    const res = await fetch(input.uri);\n    const blob = await res.blob();\n    const name =\n      input.fileName ||\n      \"upload_\" +\n        Date.now() +\n        \"_\" +\n        idx +\n        (extFromMime(input.mimeType || blob.type) || \".bin\");\n    return { blob, name: safeName(name) };\n  }\n\n  // STRING (blob:/file:/content:/http:)\n  if (typeof input === \"string\") {\n    const res = await fetch(input);\n    const blob = await res.blob();\n    const name =\n      \"upload_\" + Date.now() + \"_\" + idx + (extFromMime(blob.type) || \".bin\");\n    return { blob, name: safeName(name) };\n  }\n\n  throw new Error(\"Formato de arquivo não suportado\");\n}\n\nexport const uploadFileTool = async (props: Tprops) => {\n  console.log(\"UPLOAD DE ARQUIVOS\");\n  const { args, pass } = props;\n  const { arrFiles, arrFuncs } = pass || {};\n  console.log({ arrFiles, arrFuncs });\n\n  if (!arrFiles || !arrFiles.length) return [];\n\n  const resolved = arrFiles.map((v) => testVarType(v, args));\n  const inputs: any[] = Array.isArray(resolved[0]) ? resolved[0] : resolved;\n  console.log(\"inputs normalizados:\", inputs);\n\n  const fbInit = getCtData(\"all.temp.fireInit\");\n  const storage = getStorage(fbInit);\n\n  // --- faz upload de cada imagem e guarda as URLs\n  const condDirectory = arrFiles.some((item) => item.includes(\"documents\"));\n  const condPath = condDirectory ? \"documents/\" : \"images/\";\n  const results = await Promise.all(\n    inputs.map(async (currData: any, idx: number) => {\n      try {\n        const data = await toBlobAndName(currData, idx);\n        const blob = data.blob;\n        const name = data.name;\n        const path = condPath + Date.now() + \"_\" + idx + \"_\" + name;\n        const fileRef = ref(storage, path);\n\n        await uploadBytes(fileRef, blob);\n        const url = await getDownloadURL(fileRef);\n\n        console.log(\"upload ok:\", { idx, path, url });\n        return { ok: true, idx: idx, url: url, path: path };\n      } catch (err) {\n        console.error(\"falha no upload:\", idx, err);\n        return { ok: false, idx: idx, error: String(err) };\n      }\n    })\n  );\n\n  // --- coleta somente as URLs válidas\n  const urls = results.filter((r) => r.ok).map((r) => r.url);\n  console.log(\"URLs finais:\", urls);\n\n  // --- chama funções externas APÓS todos os uploads\n  if (arrFuncs && arrFuncs.length) {\n    for (const fn of arrFuncs) {\n      await fn(args, urls);\n    }\n  }\n\n  console.log(\"Resultados:\", results);\n  return results;\n};\n"}}