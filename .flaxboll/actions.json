{"1761752954094":{"actionType":"saveAll","createdAt":"1761752954094","actionID":"1761752954094","userID":"#TEMP","path":"system.capsules.8abe2226-b89c-4398-b08f-50f59f28b837.capsUseCodeInfo.capsUseInputs.sss_custom_caps-0.capsIptTxtValue","oldValue":"(txt) => {\n  try {\n    // Garante string\n    if (typeof txt !== \"string\") txt = String(txt ?? \"\");\n\n    console.log(\"Raw recebido:\", txt, \" (type:\", typeof txt + \")\");\n\n    // Método 1: preferencial - pega todos os dígitos com match\n    let digitArr = txt.match(/\\d/g);\n    let digits = (digitArr && digitArr.length) ? digitArr.join(\"\") : \"\";\n\n    // Se match falhar por algum motivo, fallback robusto:\n    if (!digits) {\n      digits = Array.from(txt).filter(ch => \"0123456789\".includes(ch)).join(\"\");\n    }\n\n    console.log(\"Somente dígitos extraídos:\", digits);\n\n    // Limita a 8 dígitos (DDMMAAAA)\n    digits = digits.slice(0, 8);\n\n    // Formata dinamicamente DD/MM/AAAA\n    let formatted = digits;\n    if (digits.length > 4) {\n      // quando tem DDMM + AAAA...\n      formatted = digits.replace(/^(\\d{2})(\\d{2})(\\d{0,4})/, \"$1/$2/$3\");\n    } else if (digits.length > 2) {\n      // quando tem DD + MM\n      formatted = digits.replace(/^(\\d{2})(\\d{0,2})/, \"$1/$2\");\n    }\n\n    console.log(\"Formatado:\", formatted);\n\n    // Salva no contexto (usar o que seu projeto aceita; tools.setData é preferível aqui)\n    if (typeof tools.setData === \"function\") {\n      tools.setData({\n        path: \"sc.a1.iptChanges.startDate\",\n        value: formatted\n      });\n    } else if (tools.functions && typeof tools.functions.setVar === \"function\") {\n      tools.functions.setVar({\n        args: \"\",\n        pass: {\n          keyPath: [\"sc.a1.iptChanges.startDate\"],\n          value: formatted // ou [formatted] se seu projeto usar array\n        }\n      });\n    } else {\n      console.warn(\"Nenhum setter disponível (tools.setData / tools.functions.setVar).\");\n    }\n\n    // retornar caso o componente use o retorno\n    return formatted;\n  } catch (err) {\n    console.error(\"Erro na máscara de data:\", err);\n    return txt;\n  }\n}\n","newValue":"(txt) => {\n  // Garantir que txt seja string\n  txt = txt ? String(txt) : \"\";\n\n  // Extrai apenas números\n  let digits = txt.replace(/\\D/g, \"\").slice(0, 8);\n\n  // Formata como DD/MM/AAAA\n  let formatted = \"\";\n  if (digits.length > 4) {\n    formatted = digits.replace(/^(\\d{2})(\\d{2})(\\d{0,4})$/, \"$1/$2/$3\");\n  } else if (digits.length > 2) {\n    formatted = digits.replace(/^(\\d{2})(\\d{0,2})$/, \"$1/$2\");\n  } else {\n    formatted = digits;\n  }\n\n  console.log(\"Digitado:\", txt);\n  console.log(\"Formatado:\", formatted);\n\n  // Atualiza a variável no Flaxboll\n  tools.setData({\n    path: \"sc.a1.iptChanges.startDate\",\n    value: formatted,\n  });\n\n  // Retorna o valor formatado para que o input mostre\n  return formatted;\n}\n"}}