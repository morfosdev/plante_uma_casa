{"1755806677838":{"actionType":"saveAll","createdAt":"1755806677838","actionID":"1755806677838","userID":"#TEMP","path":"system.capsules.4a541072-7bf3-4396-87fd-11e9879a9e04.capsUseCodeInfo.capsUseInputs.sss_freeValue-0.capsIptTxtValue","oldValue":"// ---------- import Packs\nimport React from 'react';\nimport JSON5 from 'json5';\nimport { TextInput } from 'react-native';\n\n// ---------- import Local Tools\nimport { getVarValue, getStlValues, pathSel, setData } from '../project';\nimport { useData } from '../../..';\n\ntype TFunc = (val: string, args?: any) => any | Promise<any>;\n\ntype Tprops = {\n  pass: {\n    propsArray?: any[];\n    stylesArray?: any[];\n    funcsArray?: TFunc[]; // opcional\n    path: (string | number)[];\n    args?: any;\n  };\n};\n\n// IptTxtEdit - Entrada de Texto com prop value\nexport const IptTxtEdit = (props: Tprops) => {\n  const {\n    propsArray = [],\n    stylesArray = [],\n    funcsArray = [],\n    path,\n    args,\n  } = props.pass;\n\n  const joinedPath = path.join();\n\n  // Estado local\n  const [sttText, setText] = React.useState('');\n\n  // Leitura do store (sempre segura; só vamos usar quando for o caso)\n  const editData = useData(ct => pathSel(ct, joinedPath));\n\n  // Tem handlers externos?\n  const hasExternal = Array.isArray(funcsArray) && funcsArray.length > 0;\n\n  // Hidrata do store apenas quando há fluxo externo\n  React.useEffect(() => {\n    if (!hasExternal) return;\n    if (editData !== undefined && editData !== sttText) {\n      setText(String(editData));\n    }\n  }, [editData, hasExternal, sttText]);\n\n  // onChange: decide o “modo”\n  const getTxt = async (val: string) => {\n    if (!hasExternal) {\n      // modo interno: só estado local\n      setText(val);\n      return;\n    }\n\n    // modo externo: mantém input responsivo e sincroniza store\n    setText(val); // feedback imediato\n    setData({ path: joinedPath, value: val });\n    for (const fn of funcsArray) {\n      await fn(val, args);\n    }\n  };\n\n  // ---------- Styles\n  const stlsUser = getStlValues(stylesArray);\n\n  // ---------- Extra props do usuário\n  const userElProps: Record<string, any> = {};\n  for (const strObj of propsArray) {\n    if (!strObj || typeof strObj !== 'string') continue;\n    const parsed = JSON5.parse(strObj);\n    for (const key in parsed) {\n      const value = parsed[key];\n      const [hasVar, varValue] = getVarValue(value);\n      userElProps[key] = hasVar ? varValue : value;\n    }\n  }\n\n  const allProps = {\n    style: stlsUser,\n    value: sttText,\n    onChangeText: getTxt,\n    placeholder: 'Escreva...',\n    placeholderTextColor: '#ccc',\n\n    ...userElProps,\n  };\n\n  return <TextInput {...allProps} />;\n};","newValue":"// ---------- import Packs\nimport React from 'react';\nimport JSON5 from 'json5';\nimport { TextInput } from 'react-native';\n\n// ---------- import Local Tools\nimport { getVarValue, getStlValues, pathSel, setData } from '../project';\nimport { useData } from '../../..';\n\ntype TFunc = (val: string, args?: any) => any | Promise<any>;\n\ntype Tprops = {\n  pass: {\n    propsArray?: any[];\n    stylesArray?: any[];\n    funcsArray?: TFunc[]; // opcional\n    path: (string | number)[];\n    args?: any;\n  };\n};\n\n// IptTxtEdit - Entrada de Texto com prop value\nexport const IptTxtEdit = (props: Tprops) => {\n  const {\n    propsArray = [],\n    stylesArray = [],\n    funcsArray = [],\n    path,\n    args,\n  } = props.pass;\n\n  const joinedPath = path.join();\n\n  // Estado local\n  const [sttText, setText] = React.useState('');\n\n  // Leitura do store (sempre segura; só vamos usar quando for o caso)\n  const editData = useData(ct => pathSel(ct, joinedPath));\n\n  // Tem handlers externos?\n  const hasExternal = Array.isArray(funcsArray) && funcsArray.length > 0;\n\n  // Hidrata do store apenas quando há fluxo externo\n  React.useEffect(() => {\n    if (!hasExternal) return;\n    if (editData !== undefined && editData !== sttText) {\n      setText(String(editData));\n    }\n  }, [editData, hasExternal, sttText]);\n\n  // onChange: decide o “modo”\n  const getTxt = async (val: string) => {\n    if (!hasExternal) {\n      // modo interno: só estado local\n      setText(val);\n      return;\n    }\n\n    // modo externo: mantém input responsivo e sincroniza store\n    setText(val); // feedback imediato\n    setData({ path: joinedPath, value: val });\n    for (const fn of funcsArray) {\n      await fn(val, args);\n    }\n  };\n\n  // ---------- Styles\n  const stlsUser = getStlValues(stylesArray);\n\n  // ---------- Extra props do usuário\n  const userElProps: Record<string, any> = {};\n  for (const strObj of propsArray) {\n    if (!strObj || typeof strObj !== 'string') continue;\n    const parsed = JSON5.parse(strObj);\n    for (const key in parsed) {\n      const value = parsed[key];\n      const [hasVar, varValue] = getVarValue(value);\n      userElProps[key] = hasVar ? varValue : value;\n    }\n  }\n\n  const allProps = {\n    style: stlsUser,\n    value: sttText,\n    onChangeText: getTxt,\n    placeholder: 'Escreva...',\n    placeholderTextColor: '#ccc',\n    ...userElProps,\n  };\n\n  return <TextInput {...allProps} />;\n};"}}