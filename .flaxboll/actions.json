{"1761745044564":{"actionType":"saveAll","createdAt":"1761745044564","actionID":"1761745044564","userID":"#TEMP","path":"system.capsules.f3787e15-17c7-4547-9292-d07ec7e7ba0f.capsUseCodeInfo.capsUseInputs.sss_custom_caps-0.capsIptTxtValue","oldValue":"(value) => {\n  try {\n    // Garante string\n    value = value ?? \"\";\n    value = String(value);\n\n    // DEBUG: ver o que chega\n    console.log(\"[dateMask] raw value:\", value);\n\n    // Remove tudo que não for dígito\n    let cleaned = value.replace(/\\D/g, \"\");\n\n    // Limita a 8 dígitos (DDMMAAAA)\n    if (cleaned.length > 8) cleaned = cleaned.slice(0, 8);\n\n    // Formata dinamicamente DD/MM/AAAA\n    let formatted = cleaned;\n    if (cleaned.length > 4) {\n      formatted = cleaned.replace(/^(\\d{2})(\\d{2})(\\d{1,4}).*/, \"$1/$2/$3\");\n    } else if (cleaned.length > 2) {\n      formatted = cleaned.replace(/^(\\d{2})(\\d{1,2})/, \"$1/$2\");\n    }\n\n    // DEBUG: mostrar o resultado antes de salvar\n    console.log(\"[dateMask] formatted:\", formatted);\n\n    // SALVAR no Flaxboll - duas opções: use a que seu projeto aceita\n    // 1) Recomendada: tools.setData (salva como string simples)\n    if (typeof tools.setData === \"function\") {\n      tools.setData({\n        path: \"sc.a1.iptChanges.startDate\",\n        value: formatted\n      });\n    } else {\n      // 2) Fallback: tools.functions.setVar (alguns projetos usam esse)\n      tools.functions.setVar({\n        args: \"\",\n        pass: {\n          keyPath: [\"sc.a1.iptChanges.startDate\"],\n          // se seu projeto espera array, descomente a linha abaixo e comente a outra\n          // value: [formatted]\n          //value: formatted\n        }\n      });\n    }\n\n    // Retorna o formatado (alguns inputs usam o retorno para mostrar o novo texto)\n    return formatted;\n  } catch (err) {\n    console.error(\"[dateMask] erro:\", err);\n    return value;\n  }\n}\n","newValue":"(value) => {\n  try {\n    // Garante string\n    value = value ?? \"\";\n    value = String(value);\n\n    // DEBUG: ver o que chega\n    console.log(\"[dateMask] raw value:\", value);\n\n    // Remove tudo que não for dígito\n    let cleaned = value.replace(/\\D/g, \"\");\n\n    // Limita a 8 dígitos (DDMMAAAA)\n    if (cleaned.length > 8) cleaned = cleaned.slice(0, 8);\n\n    // Formata dinamicamente DD/MM/AAAA\n    let formatted = cleaned;\n    if (cleaned.length > 4) {\n      formatted = cleaned.replace(/^(\\d{2})(\\d{2})(\\d{1,4}).*/, \"$1/$2/$3\");\n    } else if (cleaned.length > 2) {\n      formatted = cleaned.replace(/^(\\d{2})(\\d{1,2})/, \"$1/$2\");\n    }\n\n    // DEBUG: mostrar o resultado antes de salvar\n    console.log(\"[dateMask] formatted:\", formatted);\n\n    // SALVAR no Flaxboll - duas opções: use a que seu projeto aceita\n    // 1) Recomendada: tools.setData (salva como string simples)\n    if (typeof tools.setData === \"function\") {\n      tools.setData({\n        path: \"sc.a1.iptChanges.startDate\",\n        value: formatted\n      });\n    } else {\n      // 2) Fallback: tools.functions.setVar (alguns projetos usam esse)\n      tools.functions.setVar({\n        args: \"\",\n        pass: {\n          keyPath: [\"sc.a1.iptChanges.startDate\"],\n          // se seu projeto espera array, descomente a linha abaixo e comente a outra\n          value: [formatted]\n          //value: formatted\n        }\n      });\n    }\n\n    // Retorna o formatado (alguns inputs usam o retorno para mostrar o novo texto)\n    return formatted;\n  } catch (err) {\n    console.error(\"[dateMask] erro:\", err);\n    return value;\n  }\n}\n"}}