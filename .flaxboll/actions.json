{"1764265377794":{"actionType":"saveAll","createdAt":"1764265377794","actionID":"1764265377794","userID":"#TEMP","path":"system.capsules.0e1ba4b0-147d-4499-abf4-4ed9d8debb14.capsUseCodeInfo.capsUseInputs.sss_freeValue-0.capsIptTxtValue","oldValue":"import { getDownloadURL, getStorage, ref, uploadBytes } from \"firebase/storage\";\nimport { getCtData, testVarType } from \"../../project\";\n\n// --- tipos auxiliares\ntype TUrlInfo = {\n  receiptUrl: string;\n  fileName: string;\n};\n\ntype TUploadSuccess = {\n  ok: true;\n  idx: number;\n  url: string;\n  path: string;\n  name: string; // nome salvo (safeName + prefixos)\n  originalName: string | null; // nome original do arquivo (quando existir)\n};\n\ntype TUploadError = {\n  ok: false;\n  idx: number;\n  error: string;\n};\n\ntype TUploadResult = TUploadSuccess | TUploadError;\n\ntype Tprops = {\n  args: any;\n  pass: {\n    arrFiles: any[];\n    // agora arrFuncs recebe um array de TUrlInfo\n    arrFuncs?: Array<(a: any, urls: TUrlInfo[], idx?: number) => any>;\n  };\n};\n\n// --- helpers\nconst safeName = (name: string) =>\n  (name || \"file.bin\").replace(/[^\\w.\\-]+/g, \"_\").slice(-150);\n\nconst extFromMime = (mime?: string) =>\n  mime && mime.indexOf(\"/\") !== -1 ? \".\" + mime.split(\"/\")[1] : \"\";\n\n// sempre retorna blob + nome salvo + nome original (se existir)\nasync function toBlobAndName(\n  input: any,\n  idx: number\n): Promise<{ blob: Blob; name: string; originalName: string | null }> {\n  // WEB: File real\n  if (input instanceof File) {\n    const originalName = input.name || null;\n    const name =\n      originalName ||\n      \"upload_\" +\n        Date.now() +\n        \"_\" +\n        idx +\n        (extFromMime((input as any).type) || \".bin\");\n    return { blob: input, name: safeName(name), originalName };\n  }\n\n  // WEB: Blob sem nome\n  if (input instanceof Blob) {\n    const genName =\n      \"upload_\" +\n      Date.now() +\n      \"_\" +\n      idx +\n      (extFromMime((input as any).type) || \".bin\");\n    return { blob: input, name: safeName(genName), originalName: null };\n  }\n\n  // NATIVO: { uri, fileName?, mimeType? }\n  if (input && typeof input === \"object\" && typeof input.uri === \"string\") {\n    const res = await fetch(input.uri);\n    const blob = await res.blob();\n    const originalName: string | null = input.fileName || null;\n    const name =\n      originalName ||\n      \"upload_\" +\n        Date.now() +\n        \"_\" +\n        idx +\n        (extFromMime(input.mimeType || blob.type) || \".bin\");\n    return { blob, name: safeName(name), originalName };\n  }\n\n  // STRING (blob:/file:/content:/http:)\n  if (typeof input === \"string\") {\n    const res = await fetch(input);\n    const blob = await res.blob();\n    const genName =\n      \"upload_\" + Date.now() + \"_\" + idx + (extFromMime(blob.type) || \".bin\");\n    return { blob, name: safeName(genName), originalName: null };\n  }\n\n  throw new Error(\"Formato de arquivo não suportado\");\n}\n\nexport const uploadFileTool = async (props: Tprops) => {\n  console.log(\"UPLOAD DE ARQUIVOS\");\n  const { args, pass } = props;\n  const { arrFiles, arrFuncs } = pass || {};\n  console.log({ arrFiles, arrFuncs });\n\n  if (!arrFiles || !arrFiles.length) return [];\n\n  const resolved = arrFiles.map((v) => testVarType(v, args));\n  const inputs: any[] = Array.isArray(resolved[0]) ? resolved[0] : resolved;\n  console.log(\"inputs normalizados:\", inputs);\n\n  const fbInit = getCtData(\"all.temp.fireInit\");\n  const storage = getStorage(fbInit);\n\n  // --- faz upload de cada arquivo e guarda as URLs\n  const condDirectory = arrFiles.some(\n    (item) => typeof item === \"string\" && item.includes(\"documents\")\n  );\n  const condPath = condDirectory ? \"documents/\" : \"images/\";\n\n  const results: TUploadResult[] = await Promise.all(\n    inputs.map(async (currData: any, idx: number): Promise<TUploadResult> => {\n      try {\n        const data = await toBlobAndName(currData, idx);\n        console.log(\"blob pronto:\", { idx, data });\n\n        const blob = data.blob;\n        const name = data.name;\n        const path = condPath + Date.now() + \"_\" + idx + \"_\" + name;\n        const fileRef = ref(storage, path);\n\n        await uploadBytes(fileRef, blob);\n        const url = await getDownloadURL(fileRef);\n\n        console.log(\"upload ok:\", {\n          idx,\n          path,\n          url,\n          nameSalvo: name,\n          originalName: data.originalName,\n        });\n\n        return {\n          ok: true,\n          idx,\n          url,\n          path,\n          name,\n          originalName: data.originalName,\n        };\n      } catch (err) {\n        console.error(\"falha no upload:\", idx, err);\n        return { ok: false, idx, error: String(err) };\n      }\n    })\n  );\n\n  // --- coleta somente as URLs válidas\n  const urls: TUrlInfo[] = results\n    .filter((r): r is TUploadSuccess => r.ok === true)\n    .map((r) => ({\n      receiptUrl: r.url,\n      // exibe o nome original se existir, senão o nome salvo\n      fileName: r.originalName || r.name,\n    }));\n\n  console.log(\"URLs finais:\", urls);\n\n  // --- chama funções externas APÓS todos os uploads\n  if (arrFuncs && arrFuncs.length) {\n    for (const fn of arrFuncs) {\n      await fn(args, urls);\n    }\n  }\n\n  console.log(\"Resultados:\", results);\n  return results;\n};\n","newValue":"import { getDownloadURL, getStorage, ref, uploadBytes } from \"firebase/storage\";\nimport { getCtData, testVarType } from \"../../project\";\n\n// --- tipos auxiliares\ntype TUrlInfo = {\n  receiptUrl: string;\n  fileName: string;\n};\n\ntype TUploadSuccess = {\n  ok: true;\n  idx: number;\n  url: string;\n  path: string;\n  name: string; // nome salvo (safeName + prefixos)\n  originalName: string | null; // nome original do arquivo (quando existir)\n};\n\ntype TUploadError = {\n  ok: false;\n  idx: number;\n  error: string;\n};\n\ntype TUploadResult = TUploadSuccess | TUploadError;\n\ntype Tprops = {\n  args: any;\n  pass: {\n    arrFiles: any[];\n    // agora arrFuncs recebe um array de TUrlInfo\n    arrFuncs?: Array<(a: any, urls: TUrlInfo[], idx?: number) => any>;\n  };\n};\n\n// --- helpers\nconst safeName = (name: string) =>\n  (name || \"file.bin\").replace(/[^\\w.\\-]+/g, \"_\").slice(-150);\n\nconst extFromMime = (mime?: string) =>\n  mime && mime.indexOf(\"/\") !== -1 ? \".\" + mime.split(\"/\")[1] : \"\";\n\n// sempre retorna blob + nome salvo + nome original (se existir)\nasync function toBlobAndName(\n  input: any,\n  idx: number\n): Promise<{ blob: Blob; name: string; originalName: string | null }> {\n  // WEB: File real\n  if (input instanceof File) {\n    const originalName = input.name || null;\n    const name =\n      originalName ||\n      \"upload_\" +\n        Date.now() +\n        \"_\" +\n        idx +\n        (extFromMime((input as any).type) || \".bin\");\n    return { blob: input, name: safeName(name), originalName };\n  }\n\n  // WEB: Blob sem nome\n  if (input instanceof Blob) {\n    const genName =\n      \"upload_\" +\n      Date.now() +\n      \"_\" +\n      idx +\n      (extFromMime((input as any).type) || \".bin\");\n    return { blob: input, name: safeName(genName), originalName: null };\n  }\n\n  // NATIVO: { uri, fileName?, mimeType? }\n  if (input && typeof input === \"object\" && typeof input.uri === \"string\") {\n    const res = await fetch(input.uri);\n    const blob = await res.blob();\n    const originalName: string | null = input.fileName || null;\n    const name =\n      originalName ||\n      \"upload_\" +\n        Date.now() +\n        \"_\" +\n        idx +\n        (extFromMime(input.mimeType || blob.type) || \".bin\");\n    return { blob, name: safeName(name), originalName };\n  }\n\n  // STRING (blob:/file:/content:/http:)\n  if (typeof input === \"string\") {\n    const res = await fetch(input);\n    const blob = await res.blob();\n    const genName =\n      \"upload_\" + Date.now() + \"_\" + idx + (extFromMime(blob.type) || \".bin\");\n    return { blob, name: safeName(genName), originalName: null };\n  }\n\n  throw new Error(\"Formato de arquivo não suportado\");\n}\n\nexport const uploadFileTool = async (props: Tprops) => {\n  console.log(\"UPLOAD DE ARQUIVOS\");\n  const { args, pass } = props;\n  const { arrFiles, arrFuncs } = pass || {};\n  console.log({ arrFiles, arrFuncs });\n\n  if (!arrFiles || !arrFiles.length) return [];\n\n  const resolved = arrFiles.map((v) => testVarType(v, args));\n  const inputs: any[] = Array.isArray(resolved[0]) ? resolved[0] : resolved;\n  console.log(\"inputs normalizados:\", inputs);\n\n  const fbInit = getCtData(\"all.temp.fireInit\");\n  const storage = getStorage(fbInit);\n\n  // --- faz upload de cada arquivo e guarda as URLs\n  const condDirectory = arrFiles.some(\n    (item) => typeof item === \"string\" && item.includes(\"documents\")\n  );\n  const condPath = condDirectory ? \"documents/\" : \"images/\";\n\n  const results: TUploadResult[] = await Promise.all(\n    inputs.map(async (currData: any, idx: number): Promise<TUploadResult> => {\n      try {\n        const data = await toBlobAndName(currData, idx);\n        console.log(\"blob pronto:\", { idx, data });\n\n        const blob = data.blob;\n        const name = data.name;\n        const path = condPath + Date.now() + \"_\" + idx + \"_\" + name;\n        const fileRef = ref(storage, path);\n\n        await uploadBytes(fileRef, blob);\n        const url = await getDownloadURL(fileRef);\n\n        console.log(\"upload ok:\", {\n          idx,\n          path,\n          url,\n          nameSalvo: name,\n          originalName: data.originalName,\n        });\n\n        return {\n          ok: true,\n          idx,\n          url,\n          path,\n          name,\n          originalName: data.originalName,\n        };\n      } catch (err) {\n        console.error(\"falha no upload:\", idx, err);\n        return { ok: false, idx, error: String(err) };\n      }\n    })\n  );\n\n  // --- coleta somente as URLs válidas\n  const urls: TUrlInfo[] = results\n    .filter((r): r is TUploadSuccess => r.ok === true)\n    .map((r) => ({\n      receiptUrl: r.url,\n      // exibe o nome original se existir, senão o nome salvo\n      fileName: r.originalName || r.name,\n    }));\n\n  console.log(\"URLs finais:\", urls);\n\n  // --- chama funções externas APÓS todos os uploads\n  if (arrFuncs && arrFuncs.length) {\n    for (const fn of arrFuncs) {\n      await fn(args, urls);\n    }\n  }\n\n  console.log(\"Resultados:\", results);\n  return results;\n};"}}