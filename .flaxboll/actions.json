{"1759774217358":{"actionType":"saveAll","createdAt":"1759774217358","actionID":"1759774217358","userID":"#TEMP","path":"system.capsules.601f77d6-dc04-48f5-aa75-03dbda348961.capsUseCodeInfo.capsUseInputs.sss_freeValue-0.capsIptTxtValue","oldValue":"// ---------- import Local Tools\nimport { getFirestore, doc, updateDoc, Timestamp } from 'firebase/firestore';\nimport { getCtData, testVarType } from '../../project';\n\nexport const css1 =\n  'color: #ffb73b; background-color: black; font-size: 11px; padding: 2px 6px; border-radius: 3px';\nexport const css2 =\n  'color: black; background-color: #ffb73b; font-size: 10px; padding: 2px 6px; border-radius: 3px';\n\ntype Tprops = {\n  args: any;\n  pass: {\n    arrRefStrings: string[];\n    arrPathData: string[];\n    arrFuncs: any[];\n  };\n};\n\nexport const updateDocTool = async (props: Tprops) => {\n  // ---------- set Props\n  const { args, pass } = props;\n  const { arrRefStrings, arrPathData, arrFuncs } = pass;\n\n  // -----------------------------\n  // ---------- set Firestore Call\n  // -----------------------------\n  const newArrStringRefs = arrRefStrings.map(i => {\n    const varValue = testVarType(i, args);\n    return varValue;\n  });\n\n  console.log('3', { newArrStringRefs });\n\n  const fbInit = getCtData('all.temp.fireInit');\n  console.log(fbInit);\n  const fireInit: any = getFirestore(fbInit);\n  console.log({ arrRefStrings });\n  const refColl = doc(fireInit, ...newArrStringRefs);\n\n  // ------ check Data\n  if (!Array.isArray(arrRefStrings))\n    return console.log(\n      'arrRefStrings needs to be a string array',\n      arrRefStrings,\n    );\n\n  // ------ read Data\n  let dataToUpdate: any = {};\n  const newPath = arrPathData.map(i => {\n    const varValue = testVarType(i, args);\n    return varValue;\n  });\n  dataToUpdate = getCtData(newPath.join('.'));\n\n  // ------ add date update\n  dataToUpdate.updatedAt = Timestamp.now();\n\n  await updateDoc(refColl, dataToUpdate).catch(err =>\n    console.log('Erro do updateDoc', { err }),\n  );\n\n  // ---------- set Get Value Functions\n  for (const currFunc of arrFuncs) await currFunc(dataToUpdate, args);\n\n  console.log('%cupdateDoc ok', css1);\n  console.log('%cReferencia do Documento', css2, {\n    newArrStringRefs,\n    dataToUpdate,\n  });\n\n  return dataToUpdate;\n};\n","newValue":"// ---------- import Local Tools\nimport { getFirestore, doc, updateDoc, Timestamp } from 'firebase/firestore';\nimport { getCtData, testVarType } from '../../project';\n\nexport const css1 =\n  'color: #ffb73b; background-color: black; font-size: 11px; padding: 2px 6px; border-radius: 3px';\nexport const css2 =\n  'color: black; background-color: #ffb73b; font-size: 10px; padding: 2px 6px; border-radius: 3px';\n\ntype Tprops = {\n  args: any;\n  pass: {\n    arrRefStrings: string[];\n    arrPathData: string[];\n    arrFuncs: any[];\n  };\n};\n\nexport const updateDocTool = async (props: Tprops) => {\n  // ---------- set Props\n  const { args, pass } = props;\n  const { arrRefStrings, arrPathData, arrFuncs } = pass;\n\n  // -----------------------------\n  // ---------- set Firestore Call\n  // -----------------------------\n  const newArrStringRefs = arrRefStrings.map(i => {\n    const varValue = testVarType(i, args);\n    return varValue;\n  });\n\n  console.log('3', { newArrStringRefs });\n\n  const fbInit = getCtData('all.temp.fireInit');\n  console.log(fbInit);\n  const fireInit: any = getFirestore(fbInit);\n  console.log({ arrRefStrings });\n  const refColl = doc(fireInit, ...newArrStringRefs);\n\n  // ------ check Data\n  if (!Array.isArray(arrRefStrings))\n    return console.log(\n      'arrRefStrings needs to be a string array',\n      arrRefStrings,\n    );\n\n  // ------ read Data\n  const newPath = arrPathData.map(i => testVarType(i, args));\n  console.log({ newPath });\n\n  let pathStr: string | undefined;\n  let fetched: any;\n\n  // se for array de strings\n  if (newPath.every(i => typeof i === 'string')) {\n    pathStr = newPath.join('.');\n    console.log({ pathStr });\n    fetched = getCtData(pathStr);\n  }\n  // se for array de objetos → faz um merge (flat) em um único objeto\n  else if (newPath.every(i => typeof i === 'object' && i !== null)) {\n    const mergedObj = Object.assign({}, ...newPath);\n    console.log({ mergedObj });\n    fetched = mergedObj;\n  }\n  // caso misto ou inválido\n  else {\n    console.warn('newPath contém tipos mistos ou inválidos:', newPath);\n    fetched = {};\n  }\n\n  console.log({ fetched });\n\n  // --- garante objeto\n  const baseUpdate =\n    fetched && typeof fetched === 'object' && !Array.isArray(fetched)\n      ? { ...fetched }\n      : {};\n\n  const dataToUpdate = {\n    ...baseUpdate,\n    updatedAt: Timestamp.now(),\n  };\n\n  console.log({ dataToUpdate });\n\n  await updateDoc(refColl, dataToUpdate).catch(err =>\n    console.log('Erro do updateDoc', { err }),\n  );\n\n  // ---------- set Get Value Functions\n  for (const currFunc of arrFuncs) await currFunc(dataToUpdate, args);\n\n  console.log('%cupdateDoc ok', css1);\n  console.log('%cReferencia do Documento', css2, {\n    newArrStringRefs,\n    dataToUpdate,\n  });\n\n  return dataToUpdate;\n};\n"}}