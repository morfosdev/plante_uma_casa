{"1765386160318":{"actionType":"saveAll","createdAt":"1765386160318","actionID":"1765386160318","userID":"#TEMP","path":"system.capsules.5f847390-fb21-426a-945f-ebb2ce80f754.capsUseCodeInfo.capsUseInputs.sss_custom_caps_el-0.capsIptTxtValue","oldValue":"() => {\n  const arrImages =\n    useData((ct) => ct.sc?.C6?.forms?.editChanges?.arrImages) ?? [];\n\n  const getFileNameFromUrl = (url?: string, fallback = \"arquivo\") => {\n    if (!url) return fallback;\n    try {\n      const lastChunk = url.split(\"/\").pop() || fallback;\n      return lastChunk.split(\"?\")[0] || fallback;\n    } catch {\n      return fallback;\n    }\n  };\n\n  const resolveFileName = (url?: string, fileName?: string) => {\n    // base inicial: usa fileName se veio do Firestore, senão extrai da URL\n    let base =\n      (fileName && fileName.trim()) || getFileNameFromUrl(url, \"arquivo\");\n\n    // tenta achar extensão já presente no nome\n    let ext = \"\";\n    const nameExtMatch = base.match(/\\.(jpg|jpeg|png|pdf)$/i);\n    if (nameExtMatch) {\n      ext = nameExtMatch[0].toLowerCase();\n    }\n\n    // se não tiver extensão no nome, tenta pela URL\n    if (!ext && url) {\n      const urlExtMatch = url.match(/\\.(jpg|jpeg|png|pdf)/i);\n      if (urlExtMatch) ext = urlExtMatch[0].toLowerCase();\n    }\n\n    const cleanFileName = (txt = \"\") => {\n      let out = \"\";\n\n      for (let i = 0; i < txt.length; i++) {\n        const ch = txt[i];\n\n        // 1. Trocar \"%2F\" por \"_\"\n        if (\n          ch === \"%\" &&\n          txt[i + 1] === \"2\" &&\n          (txt[i + 2] === \"F\" || txt[i + 2] === \"f\")\n        ) {\n          out += \"_\"; // substitui por _\n          i += 2; // pula \"2F\"\n          continue;\n        }\n\n        // 2. Trocar \"/\" por \"_\"\n        if (ch === \"/\") {\n          out += \"_\";\n          continue;\n        }\n\n        // 3. Permitir somente letras, números, \"_\", \"-\", \".\"\n        const isLetter = (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\");\n        const isNumber = ch >= \"0\" && ch <= \"9\";\n        const isAllowed = ch === \"_\" || ch === \"-\" || ch === \".\";\n\n        if (isLetter || isNumber || isAllowed) {\n          out += ch;\n        } else {\n          out += \"_\"; // substitui caracteres inválidos\n        }\n      }\n\n      return out;\n    };\n\n    // normaliza nome (remove subpastas e caracteres ruins)\n    base = cleanFileName(base);\n\n    // fallback de extensão\n    if (!ext) ext = \".jpg\";\n\n    if (!base.toLowerCase().endsWith(ext)) {\n      base += ext;\n    }\n\n    return { name: base, ext }; // ex: { name: \"images_1764_0___.jpg\", ext: \".jpg\" }\n  };\n\n  const { width } = RN.useWindowDimensions();\n  const isSmall = width < 200;\n  const itemWidth = isSmall ? \"100%\" : \"48%\";\n\n  const styles = RN.StyleSheet.create({\n    container: {\n      flexDirection: \"row\",\n      flexWrap: \"wrap\",\n      justifyContent: \"space-between\",\n      padding: 16,\n    },\n    img: {\n      width: isSmall ? \"100%\" : \"48%\",\n      height: 55,\n      borderRadius: 8,\n      marginBottom: 10,\n    },\n    pressable: {\n      width: itemWidth,\n      marginBottom: 16,\n    },\n  });\n\n  // --------- Native (Android / iOS) ----------\n  const handleDownloadNative = async (url: string, fileName?: string) => {\n    try {\n      if (!url) {\n        RN.Alert.alert(\"Arquivo inválido\", \"URL não encontrada.\");\n        return;\n      }\n\n      const { name, ext } = resolveFileName(url, fileName);\n      const baseDir = FileSystem.documentDirectory + \"downloads/\";\n\n      // garante diretório\n      const dirInfo = await FileSystem.getInfoAsync(baseDir);\n      if (!dirInfo.exists) {\n        await FileSystem.makeDirectoryAsync(baseDir, { intermediates: true });\n      }\n\n      const fileUri = baseDir + name;\n      console.log(\"Baixando para:\", fileUri);\n\n      const result = await FileSystem.downloadAsync(url, fileUri);\n      console.log(\"Download concluído:\", result.uri);\n\n      // IMAGENS -> tenta salvar na GALERIA\n      if (ext === \".jpg\" || ext === \".jpeg\" || ext === \".png\") {\n        try {\n          await MediaLibrary.saveToLibraryAsync(result.uri);\n          RN.Alert.alert(\"Sucesso\", `Imagem salva na galeria como ${name}`);\n          return;\n        } catch (e) {\n          console.log(\n            \"Erro ao salvar na galeria, fazendo fallback para share:\",\n            e\n          );\n          // se não conseguir salvar na galeria, cai no share sheet\n          if (await Sharing.isAvailableAsync()) {\n            await Sharing.shareAsync(result.uri);\n            return;\n          }\n        }\n      }\n\n      // OUTROS ARQUIVOS (PDF, etc) -> SHARE SHEET\n      if (await Sharing.isAvailableAsync()) {\n        await Sharing.shareAsync(result.uri);\n      } else {\n        RN.Alert.alert(\"Download concluído\", \"Arquivo salvo em: \" + result.uri);\n      }\n    } catch (err) {\n      console.log(\"Erro no download:\", err);\n      RN.Alert.alert(\"Erro\", \"Não foi possível baixar o arquivo.\");\n    }\n  };\n\n  // --------- Web ----------\n  const handleDownloadWeb = async (url: string, fileName?: string) => {\n    if (!url) return;\n\n    const { name } = resolveFileName(url, fileName);\n\n    try {\n      // baixa o arquivo como blob\n      const response = await fetch(url);\n      const blob = await response.blob();\n\n      // cria uma URL temporária para o blob\n      const blobUrl = URL.createObjectURL(blob);\n\n      const link = document.createElement(\"a\");\n      link.href = blobUrl;\n      link.download = name; // força o nome do arquivo no download\n\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n\n      // libera a URL temporária\n      URL.revokeObjectURL(blobUrl);\n    } catch (err) {\n      console.log(\"Erro no download web:\", err);\n\n      // fallback: abre em nova aba se der algum problema\n      const link = document.createElement(\"a\");\n      link.href = url;\n      link.target = \"_blank\";\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n    }\n  };\n\n  // --------- Handler unificado ----------\n  const handlePress = (item: any) => {\n    const url = item?.receiptUrl;\n    const name = item?.fileName;\n\n    if (!url) return;\n\n    if (RN.Platform.OS === \"web\") {\n      handleDownloadWeb(url, name);\n    } else {\n      handleDownloadNative(url, name);\n    }\n  };\n\n  // --------- Render ----------\n  return (\n    <RN.ScrollView contentContainerStyle={styles.container}>\n      {arrImages.map((item: any, idx: number) => (\n        <RN.Pressable\n          key={idx}\n          onPress={() => handlePress(item)}\n          style={styles.pressable}\n        >\n          <RN.Image source={{ uri: item?.receiptUrl }} style={styles.img} />\n        </RN.Pressable>\n      ))}\n    </RN.ScrollView>\n  );\n}\n","newValue":"() => {\n  const arrImages =\n    useData((ct) => ct.sc?.C6?.forms?.editChanges?.arrImages) ?? [];\n\n  const getFileNameFromUrl = (url?: string, fallback = \"arquivo\") => {\n    if (!url) return fallback;\n    try {\n      const lastChunk = url.split(\"/\").pop() || fallback;\n      return lastChunk.split(\"?\")[0] || fallback;\n    } catch {\n      return fallback;\n    }\n  };\n\n  const resolveFileName = (url?: string, fileName?: string) => {\n    // base inicial: usa fileName se veio do Firestore, senão extrai da URL\n    let base =\n      (fileName && fileName.trim()) || getFileNameFromUrl(url, \"arquivo\");\n\n    // tenta achar extensão já presente no nome\n    let ext = \"\";\n    const nameExtMatch = base.match(/\\.(jpg|jpeg|png|pdf)$/i);\n    if (nameExtMatch) {\n      ext = nameExtMatch[0].toLowerCase();\n    }\n\n    // se não tiver extensão no nome, tenta pela URL\n    if (!ext && url) {\n      const urlExtMatch = url.match(/\\.(jpg|jpeg|png|pdf)/i);\n      if (urlExtMatch) ext = urlExtMatch[0].toLowerCase();\n    }\n\n    const cleanFileName = (txt = \"\") => {\n      let out = \"\";\n\n      for (let i = 0; i < txt.length; i++) {\n        const ch = txt[i];\n\n        // 1. Trocar \"%2F\" por \"_\"\n        if (\n          ch === \"%\" &&\n          txt[i + 1] === \"2\" &&\n          (txt[i + 2] === \"F\" || txt[i + 2] === \"f\")\n        ) {\n          out += \"_\"; // substitui por _\n          i += 2; // pula \"2F\"\n          continue;\n        }\n\n        // 2. Trocar \"/\" por \"_\"\n        if (ch === \"/\") {\n          out += \"_\";\n          continue;\n        }\n\n        // 3. Permitir somente letras, números, \"_\", \"-\", \".\"\n        const isLetter = (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\");\n        const isNumber = ch >= \"0\" && ch <= \"9\";\n        const isAllowed = ch === \"_\" || ch === \"-\" || ch === \".\";\n\n        if (isLetter || isNumber || isAllowed) {\n          out += ch;\n        } else {\n          out += \"_\"; // substitui caracteres inválidos\n        }\n      }\n\n      return out;\n    };\n\n    // normaliza nome (remove subpastas e caracteres ruins)\n    base = cleanFileName(base);\n\n    // fallback de extensão\n    if (!ext) ext = \".jpg\";\n\n    if (!base.toLowerCase().endsWith(ext)) {\n      base += ext;\n    }\n\n    return { name: base, ext }; // ex: { name: \"images_1764_0___.jpg\", ext: \".jpg\" }\n  };\n\n  const { width } = RN.useWindowDimensions();\n  const isSmall = width < 200;\n  const itemWidth = isSmall ? \"100%\" : \"48%\";\n\n  const styles = RN.StyleSheet.create({\n    container: {\n      flexDirection: \"row\",\n      flexWrap: \"wrap\",\n      justifyContent: \"space-between\",\n      padding: 16,\n    },\n    img: {\n      width: isSmall ? \"100%\" : \"48%\",\n      height: 55,\n      borderRadius: 8,\n      marginBottom: 10,\n    },\n    pressable: {\n      width: itemWidth,\n      marginBottom: 16,\n    },\n  });\n\n  // --------- Native (Android / iOS) ----------\n  const handleDownloadNative = async (url: string, fileName?: string) => {\n    try {\n      if (!url) {\n        RN.Alert.alert(\"Arquivo inválido\", \"URL não encontrada.\");\n        return;\n      }\n\n      const { name, ext } = resolveFileName(url, fileName);\n      const baseDir = FileSystem.documentDirectory + \"downloads/\";\n\n      // garante diretório\n      const dirInfo = await FileSystem.getInfoAsync(baseDir);\n      if (!dirInfo.exists) {\n        await FileSystem.makeDirectoryAsync(baseDir, { intermediates: true });\n      }\n\n      const fileUri = baseDir + name;\n      console.log(\"Baixando para:\", fileUri);\n\n      const result = await FileSystem.downloadAsync(url, fileUri);\n      console.log(\"Download concluído:\", result.uri);\n\n      // IMAGENS -> tenta salvar na GALERIA\n      if (ext === \".jpg\" || ext === \".jpeg\" || ext === \".png\") {\n        try {\n          await MediaLibrary.saveToLibraryAsync(result.uri);\n          RN.Alert.alert(\"Sucesso\", `Imagem salva na galeria como ${name}`);\n          return;\n        } catch (e) {\n          console.log(\n            \"Erro ao salvar na galeria, fazendo fallback para share:\",\n            e\n          );\n          // se não conseguir salvar na galeria, cai no share sheet\n          if (await Sharing.isAvailableAsync()) {\n            await Sharing.shareAsync(result.uri);\n            return;\n          }\n        }\n      }\n\n      // OUTROS ARQUIVOS (PDF, etc) -> SHARE SHEET\n      if (await Sharing.isAvailableAsync()) {\n        await Sharing.shareAsync(result.uri);\n      } else {\n        RN.Alert.alert(\"Download concluído\", \"Arquivo salvo em: \" + result.uri);\n      }\n    } catch (err) {\n      console.log(\"Erro no download:\", err);\n      RN.Alert.alert(\"Erro\", \"Não foi possível baixar o arquivo.\");\n    }\n  };\n\n  // --------- Web ----------\n  const handleDownloadWeb = async (url: string, fileName?: string) => {\n    if (!url) return;\n\n    const { name } = resolveFileName(url, fileName);\n\n    try {\n      // baixa o arquivo como blob\n      const response = await fetch(url);\n      const blob = await response.blob();\n\n      // cria uma URL temporária para o blob\n      const blobUrl = URL.createObjectURL(blob);\n\n      const link = document.createElement(\"a\");\n      link.href = blobUrl;\n      link.download = name; // força o nome do arquivo no download\n\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n\n      // libera a URL temporária\n      URL.revokeObjectURL(blobUrl);\n    } catch (err) {\n      console.log(\"Erro no download web:\", err);\n\n      // fallback: abre em nova aba se der algum problema\n      const link = document.createElement(\"a\");\n      link.href = url;\n      link.target = \"_blank\";\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n    }\n  };\n\n  // --------- Handler unificado ----------\n  const handlePress = (item: any) => {\n    const url = item?.receiptUrl;\n    const name = item?.fileName;\n\n    if (!url) return;\n\n    if (RN.Platform.OS === \"web\") {\n      handleDownloadWeb(url, name);\n    } else {\n      handleDownloadNative(url, name);\n    }\n  };\n\n  // --------- Render ----------\n  return (\n    <RN.ScrollView contentContainerStyle={styles.container}>\n      {arrImages.map((item: any, idx: number) => (\n        <RN.Pressable\n          key={idx}\n          onPress={() => handlePress(item)}\n          style={styles.pressable}\n        >\n          <RN.Image source={{ uri: item?.receiptUrl }} style={styles.img} />\n        </RN.Pressable>\n      ))}\n    </RN.ScrollView>\n  );\n}"}}