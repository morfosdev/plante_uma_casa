{"1769451045598":{"actionType":"saveAll","createdAt":"1769451045598","actionID":"1769451045598","userID":"#TEMP","path":"system.capsules.d0159c97-dd49-4afe-a532-e146edf8c85a.capsUseCodeInfo.capsUseInputs.ccc_stringValue-0.capsIptTxtValue","oldValue":"{\ncolor: 'white',\n}","newValue":"{\n\tcolor: 'white',\n}"},"1769451045599":{"actionType":"saveAll","createdAt":"1769451045599","actionID":"1769451045599","userID":"#TEMP","path":"system.capsules.4bfb5273-e682-452d-9c46-7dc8d1b2ac76.capsUseCodeInfo.capsUseInputs.sss_custom_caps_el-0.capsIptTxtValue","oldValue":"() => {\n  const arrDocuments =\n    useData((ct) => ct.sc?.C6?.forms?.editChanges?.arrDocuments) ?? [];\n\n  const styles = RN.StyleSheet.create({\n    container: {\n      flexDirection: \"row\",\n      flexWrap: \"wrap\",\n      justifyContent: \"space-between\",\n      paddingLeft: 16,\n      paddingRight: 16,\n    },\n    doc: {\n      width: \"100%\",\n      height: 35,\n      borderRadius: 8,\n      marginBottom: 10,\n      borderWidth: 1,\n      borderColor: \"#ccc\",\n      alignItems: \"center\",\n      padding: 8,\n    },\n    txt: {\n      fontSize: 12,\n      color: \"#666\",\n    },\n  });\n\n  const cleanFileName = (txt = \"\") => {\n    let out = \"\";\n\n    for (let i = 0; i < txt.length; i++) {\n      const ch = txt[i];\n\n      // Detecta \"%2F\"\n      if (\n        ch === \"%\" &&\n        txt[i + 1] === \"2\" &&\n        (txt[i + 2] === \"F\" || txt[i + 2] === \"f\")\n      ) {\n        out += \"_\";\n        i += 2;\n        continue;\n      }\n\n      // Barra vira \"_\"\n      if (ch === \"/\") {\n        out += \"_\";\n        continue;\n      }\n\n      // Permite apenas letras, números, \"_\", \"-\", \".\"\n      const isLetter = (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\");\n      const isNumber = ch >= \"0\" && ch <= \"9\";\n      const isAllowed = ch === \"_\" || ch === \"-\" || ch === \".\";\n\n      if (isLetter || isNumber || isAllowed) {\n        out += ch;\n      } else {\n        out += \"_\";\n      }\n    }\n    return out;\n  };\n\n  const resolveDocFileName = (url?: string, fileName?: string) => {\n    let base = (fileName && fileName.trim()) || \"arquivo\";\n\n    // tenta pegar extensão pelo nome\n    let ext = \"\";\n    const lower = base.toLowerCase();\n\n    const allowedExt = [\n      \".pdf\",\n      \".doc\",\n      \".docx\",\n      \".xls\",\n      \".xlsx\",\n      \".zip\",\n      \".txt\",\n      \".csv\",\n    ];\n\n    for (const e of allowedExt) {\n      if (lower.endsWith(e)) {\n        ext = e;\n        break;\n      }\n    }\n\n    // tenta pegar extensão pela URL\n    if (!ext && url) {\n      const urlLower = url.toLowerCase();\n      for (const e of allowedExt) {\n        if (urlLower.includes(e)) {\n          ext = e;\n          break;\n        }\n      }\n    }\n\n    // fallback\n    if (!ext) ext = \".pdf\";\n\n    // limpeza sem regex\n    base = cleanFileName(base);\n\n    if (!base.toLowerCase().endsWith(ext)) base += ext;\n\n    return { name: base, ext };\n  };\n\n  // ---------------------------------------------------------\n  // --------- DOWNLOAD NATIVO (PDF, DOC, ZIP etc.) ----------\n  // ---------------------------------------------------------\n  const handleDownloadNative = async (url: string, fileName?: string) => {\n    try {\n      if (!url) {\n        RN.Alert.alert(\"Arquivo inválido\", \"URL não encontrada.\");\n        return;\n      }\n\n      const { name } = resolveDocFileName(url, fileName);\n      const baseDir = FileSystem.documentDirectory + \"downloads_docs/\";\n\n      // cria pasta se não existir\n      const dirInfo = await FileSystem.getInfoAsync(baseDir);\n      if (!dirInfo.exists) {\n        await FileSystem.makeDirectoryAsync(baseDir, { intermediates: true });\n      }\n\n      const fileUri = baseDir + name;\n\n      const result = await FileSystem.downloadAsync(url, fileUri);\n      console.log(\"Download concluído:\", result.uri);\n\n      // abre share sheet (PDF, DOC, XLS etc.)\n      if (await Sharing.isAvailableAsync()) {\n        await Sharing.shareAsync(result.uri);\n      } else {\n        RN.Alert.alert(\"Download concluído\", result.uri);\n      }\n    } catch (err) {\n      console.log(\"Erro download:\", err);\n      RN.Alert.alert(\"Erro\", \"Não foi possível baixar o documento.\");\n    }\n  };\n\n  // ---------------------------------------------------------\n  // -------------------- DOWNLOAD WEB -----------------------\n  // ---------------------------------------------------------\n  const handleDownloadWeb = async (url: string, fileName?: string) => {\n    if (!url) return;\n\n    const { name } = resolveDocFileName(url, fileName);\n\n    try {\n      const proxy =\n        \"https://us-central1-flaxboll.cloudfunctions.net/proxyCall?url=\";\n      const resp = await fetch(proxy + url);\n      if (!resp.ok) {\n        throw new Error(\"HTTP \" + resp.status);\n      }\n\n      const blob = await resp.blob();\n      const blobUrl = URL.createObjectURL(blob);\n\n      const link = document.createElement(\"a\");\n      link.href = blobUrl;\n      link.download = name;\n\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n\n      URL.revokeObjectURL(blobUrl);\n    } catch (e) {\n      console.log(\"Erro web (fetch falhou, usando fallback <a>):\", e);\n\n      // Fallback: ainda tenta abrir/baixar usando um <a> simples\n      const link = document.createElement(\"a\");\n      link.href = url;\n      link.download = name;\n      link.target = \"_blank\"; // se não respeitar o download, pelo menos abre a aba\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n    }\n  };\n\n  // ------------------- Handler único -----------------------\n  const handlePress = (item: any) => {\n    const url = item?.fileUrl || item?.receiptUrl;\n    const name = item?.fileName;\n\n    if (!url) return;\n\n    if (RN.Platform.OS === \"web\") {\n      handleDownloadWeb(url, name);\n    } else {\n      handleDownloadNative(url, name);\n    }\n  };\n\n  // ---------------------- Render ---------------------------\n  return (\n    <RN.ScrollView contentContainerStyle={styles.container}>\n      {arrDocuments.map((item: any, idx: number) => (\n        <RN.Pressable\n          key={idx}\n          style={styles.doc}\n          onPress={() => handlePress(item)}\n        >\n          <RN.Text style={styles.txt}>{item.fileName}</RN.Text>\n        </RN.Pressable>\n      ))}\n    </RN.ScrollView>\n  );\n}","newValue":"() => {\n  const arrDocuments =\n    useData((ct) => ct.sc?.C6?.forms?.editChanges?.arrDocuments) ?? [];\n\n  const styles = RN.StyleSheet.create({\n    container: {\n      flexDirection: \"row\",\n      flexWrap: \"wrap\",\n      justifyContent: \"space-between\",\n      paddingLeft: 16,\n      paddingRight: 16,\n    },\n    doc: {\n      width: \"100%\",\n      height: 35,\n      borderRadius: 8,\n      marginBottom: 10,\n      borderWidth: 1,\n      borderColor: \"#ccc\",\n      alignItems: \"center\",\n      padding: 8,\n    },\n    txt: {\n      fontSize: 14,\n      color: \"#666\",\n    },\n  });\n\n  const cleanFileName = (txt = \"\") => {\n    let out = \"\";\n\n    for (let i = 0; i < txt.length; i++) {\n      const ch = txt[i];\n\n      // Detecta \"%2F\"\n      if (\n        ch === \"%\" &&\n        txt[i + 1] === \"2\" &&\n        (txt[i + 2] === \"F\" || txt[i + 2] === \"f\")\n      ) {\n        out += \"_\";\n        i += 2;\n        continue;\n      }\n\n      // Barra vira \"_\"\n      if (ch === \"/\") {\n        out += \"_\";\n        continue;\n      }\n\n      // Permite apenas letras, números, \"_\", \"-\", \".\"\n      const isLetter = (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\");\n      const isNumber = ch >= \"0\" && ch <= \"9\";\n      const isAllowed = ch === \"_\" || ch === \"-\" || ch === \".\";\n\n      if (isLetter || isNumber || isAllowed) {\n        out += ch;\n      } else {\n        out += \"_\";\n      }\n    }\n    return out;\n  };\n\n  const resolveDocFileName = (url?: string, fileName?: string) => {\n    let base = (fileName && fileName.trim()) || \"arquivo\";\n\n    // tenta pegar extensão pelo nome\n    let ext = \"\";\n    const lower = base.toLowerCase();\n\n    const allowedExt = [\n      \".pdf\",\n      \".doc\",\n      \".docx\",\n      \".xls\",\n      \".xlsx\",\n      \".zip\",\n      \".txt\",\n      \".csv\",\n    ];\n\n    for (const e of allowedExt) {\n      if (lower.endsWith(e)) {\n        ext = e;\n        break;\n      }\n    }\n\n    // tenta pegar extensão pela URL\n    if (!ext && url) {\n      const urlLower = url.toLowerCase();\n      for (const e of allowedExt) {\n        if (urlLower.includes(e)) {\n          ext = e;\n          break;\n        }\n      }\n    }\n\n    // fallback\n    if (!ext) ext = \".pdf\";\n\n    // limpeza sem regex\n    base = cleanFileName(base);\n\n    if (!base.toLowerCase().endsWith(ext)) base += ext;\n\n    return { name: base, ext };\n  };\n\n  // ---------------------------------------------------------\n  // --------- DOWNLOAD NATIVO (PDF, DOC, ZIP etc.) ----------\n  // ---------------------------------------------------------\n  const handleDownloadNative = async (url: string, fileName?: string) => {\n    try {\n      if (!url) {\n        RN.Alert.alert(\"Arquivo inválido\", \"URL não encontrada.\");\n        return;\n      }\n\n      const { name } = resolveDocFileName(url, fileName);\n      const baseDir = FileSystem.documentDirectory + \"downloads_docs/\";\n\n      // cria pasta se não existir\n      const dirInfo = await FileSystem.getInfoAsync(baseDir);\n      if (!dirInfo.exists) {\n        await FileSystem.makeDirectoryAsync(baseDir, { intermediates: true });\n      }\n\n      const fileUri = baseDir + name;\n\n      const result = await FileSystem.downloadAsync(url, fileUri);\n      console.log(\"Download concluído:\", result.uri);\n\n      // abre share sheet (PDF, DOC, XLS etc.)\n      if (await Sharing.isAvailableAsync()) {\n        await Sharing.shareAsync(result.uri);\n      } else {\n        RN.Alert.alert(\"Download concluído\", result.uri);\n      }\n    } catch (err) {\n      console.log(\"Erro download:\", err);\n      RN.Alert.alert(\"Erro\", \"Não foi possível baixar o documento.\");\n    }\n  };\n\n  // ---------------------------------------------------------\n  // -------------------- DOWNLOAD WEB -----------------------\n  // ---------------------------------------------------------\n  const handleDownloadWeb = async (url: string, fileName?: string) => {\n    if (!url) return;\n\n    const { name } = resolveDocFileName(url, fileName);\n\n    try {\n      const proxy =\n        \"https://us-central1-flaxboll.cloudfunctions.net/proxyCall?url=\";\n      const resp = await fetch(proxy + url);\n      if (!resp.ok) {\n        throw new Error(\"HTTP \" + resp.status);\n      }\n\n      const blob = await resp.blob();\n      const blobUrl = URL.createObjectURL(blob);\n\n      const link = document.createElement(\"a\");\n      link.href = blobUrl;\n      link.download = name;\n\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n\n      URL.revokeObjectURL(blobUrl);\n    } catch (e) {\n      console.log(\"Erro web (fetch falhou, usando fallback <a>):\", e);\n\n      // Fallback: ainda tenta abrir/baixar usando um <a> simples\n      const link = document.createElement(\"a\");\n      link.href = url;\n      link.download = name;\n      link.target = \"_blank\"; // se não respeitar o download, pelo menos abre a aba\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n    }\n  };\n\n  // ------------------- Handler único -----------------------\n  const handlePress = (item: any) => {\n    const url = item?.fileUrl || item?.receiptUrl;\n    const name = item?.fileName;\n\n    if (!url) return;\n\n    if (RN.Platform.OS === \"web\") {\n      handleDownloadWeb(url, name);\n    } else {\n      handleDownloadNative(url, name);\n    }\n  };\n\n  // ---------------------- Render ---------------------------\n  return (\n    <RN.ScrollView contentContainerStyle={styles.container}>\n      {arrDocuments.map((item: any, idx: number) => (\n        <RN.Pressable\n          key={idx}\n          style={styles.doc}\n          onPress={() => handlePress(item)}\n        >\n          <RN.Text style={styles.txt}>{item.fileName}</RN.Text>\n        </RN.Pressable>\n      ))}\n    </RN.ScrollView>\n  );\n}"}}