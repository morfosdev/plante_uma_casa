{"1764695548952":{"actionType":"saveAll","createdAt":"1764695548952","actionID":"1764695548952","userID":"#TEMP","path":"system.capsules.665979e6-3560-46a2-a871-c913d82be2e2.capsUseCodeInfo.capsUseInputs.sss_freeValue-0.capsIptTxtValue","oldValue":"// ---------- import Packs\nimport * as ImagePicker from \"expo-image-picker\";\nimport React from \"react\";\nimport * as RN from \"react-native\";\nimport { useData, useRoutes } from \"../../..\";\nimport { pathSel, setData } from \"../project\";\n\ntype Tprops = {\n  pass: {\n    variable?: string[]; // lista inicial de previews (URIs) - só UI\n    childrenItems?: any[]; // não usado\n    arrFuncs?: Array<(payload: any, args?: any) => any | Promise<any>>; // callbacks que recebem FILES/ASSETS\n    args?: any; // args repassados aos callbacks\n    onChange?: (uris: string[]) => void; // callback UI com as URIs (previews)\n    max?: number; // limite de itens\n  };\n};\n\nexport const BtnImagePicker = (props: Tprops) => {\n  const isWeb = RN.Platform.OS === \"web\";\n  return isWeb ? <BtnImgPicWeb {...props} /> : <BtnImgPicNat {...props} />;\n};\n\n/* ---------------- WEB ---------------- */\nconst BtnImgPicWeb = ({ pass }: Tprops) => {\n  const { variable = [], onChange, max, arrFuncs, args } = pass || {};\n  const inputRef = React.useRef<HTMLInputElement | null>(null);\n\n  const currRoute = useRoutes.getState().currRoute;\n  const condScA4 = currRoute === \"a4list\";\n\n  const objPaths: Record<string, string> = {\n    a4list: \"sc.a1.editChanges.arrImages\",\n    b7list: \"sc.B9.forms.editChanges.arrImages\",\n  };\n\n  const imagesPath = currRoute && objPaths[currRoute];\n  console.log({ objPaths, imagesPath, currRoute });\n  const editData = useData((ct: any) => {\n    if (!imagesPath) return undefined;\n    return pathSel(ct, imagesPath);\n  });\n\n  // UI: previews\n  const [images, setImages] = React.useState<string[]>(variable);\n  // Upload: Files reais\n  const [files, setFiles] = React.useState<File[]>([]);\n\n  // Ao iniciar componente, se existir editData, inicializa `images`\n  React.useEffect(() => {\n    if (!Array.isArray(editData) || !editData.length) return;\n\n    // Normaliza editData -> array de URLs\n    const urls = editData\n      .map((item: any) => {\n        if (!item) return \"\";\n        if (typeof item === \"string\") return item;\n\n        if (typeof item === \"object\") {\n          // ajuste aqui se seu campo tiver outro nome\n          return item.receiptUrl || item.url || item.uri || \"\";\n        }\n\n        return \"\";\n      })\n      .filter((u: string) => !!u);\n\n    if (!urls.length) return;\n\n    setImages(urls);\n    onChange?.(urls);\n  }, [editData, max, onChange]);\n\n  // Dispara callbacks sempre que os FILES mudam\n  React.useEffect(() => {\n    if (arrFuncs) for (const fn of arrFuncs) fn(files, args);\n    // revoke das URLs quando componente desmontar\n    return () =>\n      images.forEach((u) => u.startsWith(\"blob:\") && URL.revokeObjectURL(u));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [files]);\n\n  const pickWeb = () => inputRef.current?.click();\n\n  const handleWebFile = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const fl = event.target.files;\n    if (!fl) return;\n\n    const newFiles = Array.from(fl);\n    const newPreviews = newFiles.map((f) => URL.createObjectURL(f));\n\n    const nextPreviews = max\n      ? [...images, ...newPreviews].slice(0, max)\n      : [...images, ...newPreviews];\n    const nextFiles = max\n      ? [...files, ...newFiles].slice(0, max)\n      : [...files, ...newFiles];\n\n    if (condScA4) {\n      setImages(newPreviews);\n      // Aqui não precisa guardar no editChanges (feito no upload)\n      // setData({ path: imagesPath, value: newPreviews }); \n    }\n    if (!condScA4) {\n      setImages(nextPreviews);\n      // Aqui não precisa guardar no editChanges (feito no upload)\n      // setData({ path: imagesPath, value: nextPreviews });\n    }\n\n    setFiles(nextFiles);\n    onChange?.(nextPreviews);\n\n    // permitir re-selecionar os mesmos arquivos\n    event.target.value = \"\";\n  };\n\n  const removeAt = (idx: number) => {\n    const imgs = [...images];\n    const fls = [...files];\n    const [rm] = imgs.splice(idx, 1);\n    fls.splice(idx, 1);\n\n    if (rm?.startsWith(\"blob:\")) URL.revokeObjectURL(rm);\n\n    setData({ path: imagesPath, value: imgs }); // remove também do editChanges\n    setImages(imgs);\n    setFiles(fls);\n    onChange?.(imgs);\n  };\n\n  return (\n    <>\n      <RN.View style={styles.container}>\n        <ThumbGrid images={images} onRemove={removeAt} />\n        <RN.Text style={styles.title}>Adicionar Imagens</RN.Text>\n        <RN.Text style={styles.subtitle}>\n          Selecione ou tire fotos para mostrar o progresso\n        </RN.Text>\n        <RN.Pressable style={styles.btn} onPress={pickWeb}>\n          <RN.Text style={styles.btnTxt}>Adicionar</RN.Text>\n        </RN.Pressable>\n      </RN.View>\n\n      <input\n        ref={inputRef}\n        type=\"file\"\n        accept=\"image/*\"\n        multiple={condScA4 ? false : true}\n        style={{ display: \"none\" }}\n        onChange={handleWebFile}\n      />\n    </>\n  );\n};\n\n/* --------------- NATIVO --------------- */\nconst BtnImgPicNat = ({ pass }: Tprops) => {\n  const { variable = [], onChange, max, arrFuncs, args } = pass || {};\n\n  // UI: URIs para miniaturas\n  const [images, setImages] = React.useState<string[]>(variable);\n  // Upload: objetos ricos do ImagePicker\n  const [assets, setAssets] = React.useState<\n    Array<{ uri: string; fileName?: string; mimeType?: string }>\n  >([]);\n\n  // Dispara callbacks sempre que os ASSETS mudam\n  React.useEffect(() => {\n    if (arrFuncs) for (const fn of arrFuncs) fn(assets, args);\n    return () => {\n      /* nada a revogar no nativo */\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [assets]);\n\n  const pickNative = async () => {\n    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();\n    if (status !== \"granted\") {\n      alert(\"Permissão para acessar a galeria foi negada\");\n      return;\n    }\n\n    const result = await ImagePicker.launchImageLibraryAsync({\n      mediaTypes: ImagePicker.MediaTypeOptions.Images,\n      allowsMultipleSelection: true,\n      selectionLimit: max ?? 0, // 0 = sem limite (iOS; pode ser ignorado em algumas versões)\n      allowsEditing: false,\n      quality: 1,\n    });\n\n    if (!result.canceled) {\n      const newUris = result.assets.map((a) => a.uri);\n      const nextUris = max\n        ? [...images, ...newUris].slice(0, max)\n        : [...images, ...newUris];\n\n      const newAssets = result.assets.map((a) => ({\n        uri: a.uri,\n        fileName: a.fileName,\n        mimeType: a.mimeType,\n      }));\n      const nextAssets = max\n        ? [...assets, ...newAssets].slice(0, max)\n        : [...assets, ...newAssets];\n\n      setImages(nextUris); // UI\n      setAssets(nextAssets); // Upload\n      onChange?.(nextUris);\n    }\n  };\n\n  const removeAt = (idx: number) => {\n    const imgs = [...images];\n    imgs.splice(idx, 1);\n    const ats = [...assets];\n    ats.splice(idx, 1);\n    setImages(imgs);\n    setAssets(ats);\n    onChange?.(imgs);\n  };\n\n  return (\n    <RN.View style={styles.container}>\n      <ThumbGrid images={images} onRemove={removeAt} />\n      <RN.Text style={styles.title}>Adicionar Imagens</RN.Text>\n      <RN.Text style={styles.subtitle}>\n        Selecione ou tire fotos para mostrar o progresso\n      </RN.Text>\n      <RN.Pressable style={styles.btn} onPress={pickNative}>\n        <RN.Text style={styles.btnTxt}>Adicionar</RN.Text>\n      </RN.Pressable>\n    </RN.View>\n  );\n};\n\n/* ------- Grade de miniaturas reutilizável ------- */\nconst ThumbGrid = ({\n  images,\n  onRemove,\n}: {\n  images: string[];\n  onRemove: (idx: number) => void;\n}) => {\n  if (!images.length) return null;\n\n  const condNumThumbs: RN.ViewStyle =\n    images.length === 1 ? { width: \"100%\" } : {};\n\n  return (\n    <RN.View style={thumb.grid}>\n      {images.map((uri, idx) => (\n        <RN.View key={uri + idx} style={{ ...thumb.item, ...condNumThumbs }}>\n          <RN.Image source={{ uri }} style={thumb.img} />\n          <RN.Pressable\n            hitSlop={8}\n            style={thumb.x}\n            onPress={() => onRemove(idx)}\n          >\n            <RN.Text style={thumb.xTxt}>×</RN.Text>\n          </RN.Pressable>\n        </RN.View>\n      ))}\n    </RN.View>\n  );\n};\n\n/* ---------------- STYLES ---------------- */\nconst styles = RN.StyleSheet.create({\n  container: {\n    width: \"100%\",\n    minHeight: 180,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    borderStyle: \"dashed\",\n    borderColor: \"#D5DBE3\",\n    borderRadius: 12,\n    borderWidth: 2,\n    padding: 20,\n    gap: 16,\n    backgroundColor: \"#fff\",\n  },\n  title: { fontSize: 18, fontWeight: \"700\", textAlign: \"center\" },\n  subtitle: { fontSize: 14, textAlign: \"center\", color: \"#4B5563\" },\n  btn: {\n    backgroundColor: \"#E8EDF5\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    borderRadius: 10,\n    height: 36,\n    paddingHorizontal: 16,\n  },\n  btnTxt: { fontSize: 14, fontWeight: \"700\" },\n});\n\nconst thumb = RN.StyleSheet.create({\n  grid: {\n    width: \"100%\",\n    flexDirection: \"row\",\n    flexWrap: \"wrap\",\n    justifyContent: \"center\",\n    columnGap: 10,\n    rowGap: 10,\n  },\n  item: {\n    position: \"relative\",\n    width: \"45%\",\n    aspectRatio: 1.6,\n    borderRadius: 6,\n    overflow: \"hidden\",\n  },\n  img: { width: \"100%\", height: \"100%\" },\n  x: {\n    position: \"absolute\",\n    top: 4,\n    right: 4,\n    width: 22,\n    height: 22,\n    borderRadius: 11,\n    backgroundColor: \"rgba(0,0,0,0.5)\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  xTxt: { color: \"#fff\", fontSize: 16, lineHeight: 16, fontWeight: \"700\" },\n});","newValue":"// ---------- import Packs\nimport * as ImagePicker from \"expo-image-picker\";\nimport React from \"react\";\nimport * as RN from \"react-native\";\nimport { useData, useRoutes } from \"../../..\";\nimport { pathSel, setData } from \"../project\";\n\ntype Tprops = {\n  pass: {\n    variable?: string[]; // lista inicial de previews (URIs) - só UI\n    childrenItems?: any[]; // não usado\n    arrFuncs?: Array<(payload: any, args?: any) => any | Promise<any>>; // callbacks que recebem FILES/ASSETS\n    args?: any; // args repassados aos callbacks\n    onChange?: (uris: string[]) => void; // callback UI com as URIs (previews)\n    max?: number; // limite de itens\n  };\n};\n\nexport const BtnImagePicker = (props: Tprops) => {\n  const isWeb = RN.Platform.OS === \"web\";\n  return isWeb ? <BtnImgPicWeb {...props} /> : <BtnImgPicNat {...props} />;\n};\n\n/* ---------------- WEB ---------------- */\nconst BtnImgPicWeb = ({ pass }: Tprops) => {\n  const { variable = [], onChange, max, arrFuncs, args } = pass || {};\n  const inputRef = React.useRef<HTMLInputElement | null>(null);\n\n  const currRoute = useRoutes.getState().currRoute;\n  const condScA4 = currRoute === \"a4list\";\n\n  const objPaths: Record<string, string> = {\n    a4list: \"sc.a1.editChanges.arrImages\",\n    b7list: \"sc.B9.forms.editChanges.arrImages\",\n  };\n\n  const imagesPath = currRoute && objPaths[currRoute];\n  console.log({ objPaths, imagesPath, currRoute });\n  const editData = useData((ct: any) => {\n    if (!imagesPath) return undefined;\n    return pathSel(ct, imagesPath);\n  });\n\n  // UI: previews\n  const [images, setImages] = React.useState<string[]>(variable);\n  // Upload: Files reais\n  const [files, setFiles] = React.useState<File[]>([]);\n\n  // Ao iniciar componente, se existir editData, inicializa `images`\n  React.useEffect(() => {\n    if (!Array.isArray(editData) || !editData.length) return;\n\n    // Normaliza editData -> array de URLs\n    const urls = editData\n      .map((item: any) => {\n        if (!item) return \"\";\n        if (typeof item === \"string\") return item;\n\n        if (typeof item === \"object\") {\n          // ajuste aqui se seu campo tiver outro nome\n          return item.receiptUrl || item.url || item.uri || \"\";\n        }\n\n        return \"\";\n      })\n      .filter((u: string) => !!u);\n\n    if (!urls.length) return;\n\n    setImages(urls);\n    onChange?.(urls);\n  }, [editData, max, onChange]);\n\n  // Dispara callbacks sempre que os FILES mudam\n  React.useEffect(() => {\n    if (arrFuncs) for (const fn of arrFuncs) fn(files, args);\n    // revoke das URLs quando componente desmontar\n    return () =>\n      images.forEach((u) => u.startsWith(\"blob:\") && URL.revokeObjectURL(u));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [files]);\n\n  const pickWeb = () => inputRef.current?.click();\n\n  const handleWebFile = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const fl = event.target.files;\n    if (!fl) return;\n\n    const newFiles = Array.from(fl);\n    const newPreviews = newFiles.map((f) => URL.createObjectURL(f));\n\n    const nextPreviews = max\n      ? [...images, ...newPreviews].slice(0, max)\n      : [...images, ...newPreviews];\n    const nextFiles = max\n      ? [...files, ...newFiles].slice(0, max)\n      : [...files, ...newFiles];\n\n    if (condScA4) {\n      setImages(newPreviews);\n      // Aqui não precisa guardar no editChanges (feito no upload)\n      // setData({ path: imagesPath, value: newPreviews }); \n    }\n    if (!condScA4) {\n      setImages(nextPreviews);\n      // Aqui não precisa guardar no editChanges (feito no upload)\n      // setData({ path: imagesPath, value: nextPreviews });\n    }\n\n    setFiles(nextFiles);\n    onChange?.(nextPreviews);\n\n    // permitir re-selecionar os mesmos arquivos\n    event.target.value = \"\";\n  };\n\n  const removeAt = (idx: number) => {\n    const imgs = [...images];\n    const fls = [...files];\n    const [rm] = imgs.splice(idx, 1);\n    fls.splice(idx, 1);\n\n    if (rm?.startsWith(\"blob:\")) URL.revokeObjectURL(rm);\n\n    const nextEdit = editData.filter((_item: any, i: number) => i !== idx);\n    setData({ path: imagesPath, value: nextEdit }); // remove também do editChanges\n    setImages(imgs);\n    setFiles(fls);\n    onChange?.(imgs);\n  };\n\n  return (\n    <>\n      <RN.View style={styles.container}>\n        <ThumbGrid images={images} onRemove={removeAt} />\n        <RN.Text style={styles.title}>Adicionar Imagens</RN.Text>\n        <RN.Text style={styles.subtitle}>\n          Selecione ou tire fotos para mostrar o progresso\n        </RN.Text>\n        <RN.Pressable style={styles.btn} onPress={pickWeb}>\n          <RN.Text style={styles.btnTxt}>Adicionar</RN.Text>\n        </RN.Pressable>\n      </RN.View>\n\n      <input\n        ref={inputRef}\n        type=\"file\"\n        accept=\"image/*\"\n        multiple={condScA4 ? false : true}\n        style={{ display: \"none\" }}\n        onChange={handleWebFile}\n      />\n    </>\n  );\n};\n\n/* --------------- NATIVO --------------- */\nconst BtnImgPicNat = ({ pass }: Tprops) => {\n  const { variable = [], onChange, max, arrFuncs, args } = pass || {};\n\n  // UI: URIs para miniaturas\n  const [images, setImages] = React.useState<string[]>(variable);\n  // Upload: objetos ricos do ImagePicker\n  const [assets, setAssets] = React.useState<\n    Array<{ uri: string; fileName?: string; mimeType?: string }>\n  >([]);\n\n  // Dispara callbacks sempre que os ASSETS mudam\n  React.useEffect(() => {\n    if (arrFuncs) for (const fn of arrFuncs) fn(assets, args);\n    return () => {\n      /* nada a revogar no nativo */\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [assets]);\n\n  const pickNative = async () => {\n    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();\n    if (status !== \"granted\") {\n      alert(\"Permissão para acessar a galeria foi negada\");\n      return;\n    }\n\n    const result = await ImagePicker.launchImageLibraryAsync({\n      mediaTypes: ImagePicker.MediaTypeOptions.Images,\n      allowsMultipleSelection: true,\n      selectionLimit: max ?? 0, // 0 = sem limite (iOS; pode ser ignorado em algumas versões)\n      allowsEditing: false,\n      quality: 1,\n    });\n\n    if (!result.canceled) {\n      const newUris = result.assets.map((a) => a.uri);\n      const nextUris = max\n        ? [...images, ...newUris].slice(0, max)\n        : [...images, ...newUris];\n\n      const newAssets = result.assets.map((a) => ({\n        uri: a.uri,\n        fileName: a.fileName,\n        mimeType: a.mimeType,\n      }));\n      const nextAssets = max\n        ? [...assets, ...newAssets].slice(0, max)\n        : [...assets, ...newAssets];\n\n      setImages(nextUris); // UI\n      setAssets(nextAssets); // Upload\n      onChange?.(nextUris);\n    }\n  };\n\n  const removeAt = (idx: number) => {\n    const imgs = [...images];\n    imgs.splice(idx, 1);\n    const ats = [...assets];\n    ats.splice(idx, 1);\n    setImages(imgs);\n    setAssets(ats);\n    onChange?.(imgs);\n  };\n\n  return (\n    <RN.View style={styles.container}>\n      <ThumbGrid images={images} onRemove={removeAt} />\n      <RN.Text style={styles.title}>Adicionar Imagens</RN.Text>\n      <RN.Text style={styles.subtitle}>\n        Selecione ou tire fotos para mostrar o progresso\n      </RN.Text>\n      <RN.Pressable style={styles.btn} onPress={pickNative}>\n        <RN.Text style={styles.btnTxt}>Adicionar</RN.Text>\n      </RN.Pressable>\n    </RN.View>\n  );\n};\n\n/* ------- Grade de miniaturas reutilizável ------- */\nconst ThumbGrid = ({\n  images,\n  onRemove,\n}: {\n  images: string[];\n  onRemove: (idx: number) => void;\n}) => {\n  if (!images.length) return null;\n\n  const condNumThumbs: RN.ViewStyle =\n    images.length === 1 ? { width: \"100%\" } : {};\n\n  return (\n    <RN.View style={thumb.grid}>\n      {images.map((uri, idx) => (\n        <RN.View key={uri + idx} style={{ ...thumb.item, ...condNumThumbs }}>\n          <RN.Image source={{ uri }} style={thumb.img} />\n          <RN.Pressable\n            hitSlop={8}\n            style={thumb.x}\n            onPress={() => onRemove(idx)}\n          >\n            <RN.Text style={thumb.xTxt}>×</RN.Text>\n          </RN.Pressable>\n        </RN.View>\n      ))}\n    </RN.View>\n  );\n};\n\n/* ---------------- STYLES ---------------- */\nconst styles = RN.StyleSheet.create({\n  container: {\n    width: \"100%\",\n    minHeight: 180,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    borderStyle: \"dashed\",\n    borderColor: \"#D5DBE3\",\n    borderRadius: 12,\n    borderWidth: 2,\n    padding: 20,\n    gap: 16,\n    backgroundColor: \"#fff\",\n  },\n  title: { fontSize: 18, fontWeight: \"700\", textAlign: \"center\" },\n  subtitle: { fontSize: 14, textAlign: \"center\", color: \"#4B5563\" },\n  btn: {\n    backgroundColor: \"#E8EDF5\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    borderRadius: 10,\n    height: 36,\n    paddingHorizontal: 16,\n  },\n  btnTxt: { fontSize: 14, fontWeight: \"700\" },\n});\n\nconst thumb = RN.StyleSheet.create({\n  grid: {\n    width: \"100%\",\n    flexDirection: \"row\",\n    flexWrap: \"wrap\",\n    justifyContent: \"center\",\n    columnGap: 10,\n    rowGap: 10,\n  },\n  item: {\n    position: \"relative\",\n    width: \"45%\",\n    aspectRatio: 1.6,\n    borderRadius: 6,\n    overflow: \"hidden\",\n  },\n  img: { width: \"100%\", height: \"100%\" },\n  x: {\n    position: \"absolute\",\n    top: 4,\n    right: 4,\n    width: 22,\n    height: 22,\n    borderRadius: 11,\n    backgroundColor: \"rgba(0,0,0,0.5)\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  xTxt: { color: \"#fff\", fontSize: 16, lineHeight: 16, fontWeight: \"700\" },\n});\n"}}